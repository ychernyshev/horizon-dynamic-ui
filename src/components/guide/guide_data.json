{
  "en": {},
  "uk": {
    "Початок": {
      "Вступне слово": [
        {
          "type": "text",
          "content": "Маю для тебе невеличке вступне слово перед тим, як дати відповідь на питання \"Чому DUI?\"."
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Ми всі шукаємо можливості знайти вихід з певних обставин та ситуацій. Саме тому й виникла ідея для створення DUI. Але, тут зіграла, радше, зацікавленість побудувати будинок, в якого фундаментом стане горнятко молока, котре й дозволить показати, як навіть із такого, на перший погляд, крихкого ресурсу, можна збудувати масштабну систему. На базі одного-єдиного обмеженого ресурсу — статичного хостингу — створити систему, яка зазвичай потребує повноцінного VPS. І при цьому не втратити контроль, гнучкість та автономність, які статичний хостинг сильно обмежує. \"Будинок\" на ньому тобі дозволить збудувати рішення, над яким я працюю. Я прагну надати тобі для цього якомога більше тих програмних агентів та механізмів, які зроблять статичний хостинг динамічним — без втрати контролю, без бекенду, і без компромісів. Для цього роду хостингу, може бути так, ти не матимеш бажання створювати таку можливість самостійно. А, отже, DUI може стати тобі в пригоді. Чим?.</p>"
        },
        {
          "type": "text",
          "content": "<h3>Огляд Horizon Dynamic UI</h3>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Все наше життя – гра, а люди в ній – актори. Цим Шекспірівським твердженням особливо нікого не здивуєш. Але, його можна використати для створення сайту...</p>"
        },
        {
          "type": "text",
          "content": "<h3>SceneManager</h3>"
        },
        {
          "type": "text",
          "content": "<b>Збірка</b>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Все відбувається на сцені. Сценою називається головний компонент сторінки. Та щоразу, вона може бути інакшою. Немає якоїсь конкретної сцени, до якої прикріплюється різне компонування сторінок сайту та їх дизайн. Так, на головній сторінці може бути одне компанування, у документації — інакше, а у дашборті — ще якесь інше. Таким чином був видалений \"зайвий\" шар з div у <b>DOM</b>-дереві сайту. Усе монтується одразу у body index.html: </p>"
        },
        {
          "type": "code",
          "language": "html",
          "content": "< body id=\"app\">< /body>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>До сцени приєднуються інші, другорядні компоненти. Кнопка може бути компонентом. Або компонентом може бути якась форма, яка, за допомогою [Dispatcher](reactive/dispatcher.md) має доступ до LocalStorage, щоб провести якусь операцію з [додавання](interacting_with_data/localStorage/creating.md) чи [оновлення](interacting_with_data/localStorage/updating.md) запису. На твій вибір, все можна розбити на окремі компоненти, слідуючи сучасним трендам організації коду, чи все писати та створювати безпосередньо на самій сцені не боячись повторюваності коду, адже JavaScript з [mount()](deep_immersion_in_components/mount().md) або [onMount()](deep_immersion_in_components/on_mount().md) дозволить цього уникнути. З DUI можна себе не обмежувати у виборі стилю написання коду. Обидва з підходів є рівнозначними.</p>"
        },
        {
          "type": "text",
          "content": "<h3>RegistryLayoutScheme</h3>"
        },
        {
          "type": "text",
          "content": "<b>Реєстрація</b>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Сцена щоразу будується [SceneManager](deep_immersion_in_components/scene_manager.md) за заздалегідь визначеною схемою та налаштуваннями. Ці схеми та налаштування зберігаються у [RegistryLayoutScheme](essentials/scene_settings.md). Там зберігаються дані про те:</p><ul><li>базовий контейнер для монтування сцени,</li><li>список компонентів, які мають бути присутніми на сцені,</li><li>які дані мають бути передані у батьківський чи дочірні компоненти, наприклад:<ul><li>змінні,</li><li>заголовки,</li><li>списки,</li><li>блоки коду для відображення тощо</li></ul></li><li>які скрипти та стилі для кожної сцени, додатково, необхідно приєднати.</li></ul>"
        },
        {
          "type": "text",
          "content": "<h3>LayoutRegistryComponents</h3>"
        },
        {
          "type": "text",
          "content": "<b>Імпорт</b>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>А для того, щоб сцену не перевантажувати імпортами компонентів, існує окремий файл - [LayoutRegistryComponents](essentials/scene_register.md), де й представлений список усіх імпортів сцен та компонентів по всьому застосунку. Цими даними оперує [SceneManager](deep_immersion_in_components/scene_manager.md), коли сцену складає по \"кресленнях\" з [RegistryLayoutScheme](essentials/scene_settings.md). Усе зв'язано через SceneManager, тож додатково викликати нічого не потрібно. Просто, створити сцену, налаштувати її структуру та необхідні для передавання дані у LayoutRegistryComponents, зареєструвати у RegistryLayoutScheme, і SceneManager зробить усе інше.</p>"
        },
        {
          "type": "text",
          "content": "<h3>Заперечлива архітектура?</h3>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Архітектура Horizon Dynamic UI — це не протест проти традиційної залежності від бекенду, сервісів, і надмірної серверної логіки. Це необхідність у рамках статичного хостингу, що й зумовлює відмову від цих понять на час роботи із Horizon Dynamic UI,  де кожен компонент не потребує нічого, окрім браузеру та коду, яким він керує. Цей інтерфейс, як автономна система — UI, який *не просто живе у браузері*, а реагує і масштабується локально. Архітектура DUI реалізує можливість кожному агенту, компоненту і рендеру виконувати свою роль самостійно. Усе побудовано таким чином, щоб навіть без серверу можливим було рендерити динамічні дані, реагувати на взаємодію із користувачем, зберігати та аналізувати стан, та створювати логіку, як у фреймворках із повним стеком. Ми не можемо використовувати бекенд на статичних хостингах, тому ми *будуємо його у фронтенді*.</p>"
        },
        {
          "type": "text",
          "content": "<h3>Обирай продовжити! </h3>"
        },
        {
          "type": "text",
          "content": "<b>[Швидкий старт](quick-start.md)</b>"
        },
        {
          "type": "text",
          "content": "<p class='text-justify'>Покликання цієї коротенької екскурсії до DUI, надихнути тебе познайомитися із фреймворком по ближче. Адже він створений для втілення твоїх ідей у \"замкненому просторі\". Без втрати контролю, без бекенду, і без компромісів!</p>"
        }
      ],
      "Швидкий старт": [
        {
          "type": "text",
          "content": "Ця елементарна маніпуляція, дозволить вивести твою першу сцену на екран."
        },
        {
          "type": "text",
          "content": "Для цього потрібно почати зі створення самої сцени, або компоненту для неї, шляхом створення файлу із розширенням <b>*.js</b>."
        },
        {
          "type": "text",
          "content": "Існує два стилі шаблону - <b>імперативний</b> та <b>декларативний</b>, в межах котрих програмується сцена чи компонент для неї.  Не існує обмежень для використання кожного з них. Однак, для кожного з них закладена своя логіка використання."
        },
        {
          "type": "text",
          "content": "<b>Імперативний</b> стиль, на прикладі сторінки <b>404</b>, має наступний вигляд:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "export const Page_404_View = {\n    mount(config = {}) {\n        const container = document.getElementById(\"app\");\n\n        if (!container) {\n            console.warn(\"[Page_404_View] Контейнер #page_404 не знайдено — компонент не змонтовано.\");\n            return;\n        }\n\n        container.innerHTML = `\n             ...Code...\n        `;\n    }\n}"
        },
        {
          "type": "text",
          "content": "Задум використання імперативного стилю, полягає у ідеї, що у конкретному компоненті, іноді, сцені, не прогнозується використання логіки. Однак, знову ж таки, використання її не забороняється. Хоча, керування нею на сторінці вже виглядатиме не таким зручним, як у декларативному стилі сцени чи компоненту для неї."
        },
        {
          "type": "text",
          "content": "<b>Декларативний</b> стиль, навпроти, передбачає використання логіки у сцені чи то компоненті до неї, тому, виглядає дещо інакше, дозволяючи реалізувати цю логіку більш простим методом:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "export const WelcomeScene = {\n    template: `\n        ...Code...\n    `,\n    mount(config = {}) {\n        const container = document.getElementById(\"welcome-block\");\n\n        if (!container) {\n            console.warn(\"[WelcomeScene] Container #welcome-block not found - component not mounted.\");\n            return;\n        }\n\n        container.innerHTML = renderTemplate(this.template, config);\n\n        if (typeof this.onMount === \"function\") {\n            this.onMount();\n        }\n    },\n    onMount() {}\n}"
        },
        {
          "type": "text",
          "content": "У цьому варіанті стилю, кодом на сцені чи у компоненті виходить маніпулювати через блок коду <b>template</b>, що значно полегшує цю процедуру, уникаючи прямої ініціалізації контенту сторінки безпосередньо у <b>container.innerHTML = `...сode...`;</b>"
        },
        {
          "type": "text",
          "content": "Якщо блок коду <b>mount() {}</b> є точкою входу, то блок коду <b>onMount() {}</b> дозволяє розвантажити <b>mount() {}</b>, зосередивши у собі усю логіку, що має бути реалізована у компоненті (сцена, по суті, теж є компонентом, хоча її роль, бути батьківським компонентом для всіх інших її компонентів), після її створення. Назва <b>onMount</b> закладає під собою розуміння того, що код, заключений саме у цей блок почне виконуватися лише після того, як DOM буде побудовано. Але це не зобов'язує тримати <b>mount() {}</b> чистим від коду. На прикладі <b>WelcomeScene</b>, <b>mount</b> теж виконує деякі маніпуляції. У даному випадку, зі створення кнопки переходу до розділу документації <b>DUI</b>:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "mount(config = {}) {\n        const container = document.getElementById(\"welcome-block\");\n\n        if (!container) {\n            console.warn(\"[WelcomeScene] Container #welcome-block not found - component not mounted.\");\n            return;\n        }\n\n        const {title, subtitle, version, tagline, CTA} = config;\n\n        const CTA_label = config.CTA?.label || \"Explore\";\n        const CTA_link = config.CTA?.link?.trim() ? config.CTA.link : \"#page404\";\n\n        const processedConfig = {\n            ...config,\n            CTA_button: `< a href=\"${CTA_link}\" class=\"btn bg-gradient-info mt-3 fs-6\">\n                 ${CTA_label}\n                 <span class=\"badge\">${config.version}</span>\n               < /a>`\n        };\n\n\n        container.innerHTML = renderTemplate(this.template, processedConfig);\n\n        if (typeof this.onMount === \"function\") {\n            this.onMount();\n        }\n    },"
        },
        {
          "type": "text",
          "content": "Логічно кнопку створювати саме у <b>mount() {}</b>. А от логіку, яка може бути підключена до цієї кнопки, як наприклад, відправлення даних у <b>localStorage</b>, бажано розмістити у <b>onMount() {}</b>, щоб не отримати попередження, про те, що елемент по його <b>id=''</b> ще не доступний. Наприклад, для різноманітних автоматичних дій, які варто, виконувати вже після завантаження DOM-дерева сторінки. Або, для обробки події після натиску на кнопку:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "onMount() {\n        const STORAGE_KEY = \"notes\";\n\n        SceneDispatcher.subscribe(\"add-entry/save\", payload => {\n            const notes = dispatcher.get(STORAGE_KEY) || [];\n\n            const newEntry = typeof payload === \"string\"\n                ? {id: Date.now(), text: payload, timestamp: new Date().toISOString()}\n                : {\n                    id: Date.now(),\n                    text: payload.text,\n                    timestamp: new Date().toISOString()\n                };\n\n            const updatedNotes = [...notes, newEntry];\n\n            console.log(\"[Debug] Notes before saving:\", updatedNotes);\n\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedNotes));\n            dispatcher.set(STORAGE_KEY, updatedNotes);\n        });\n    }"
        },
        {
        "type": "text",
        "content": "Створений компонент необхідно зареєструвати та сконфігурувати, щоб <b>DUI</b> знав, куди компонент необхідно монтувати, які дані, наприклад <b>title</b> або якийсь статичний список вже можна передати на сцену, чи окремий компонент для неї, а також, структуру сцени, яка має бути змонтована. Останній пункт дозволяє не перевантажувати саму сцену - батьківський компонент, налаштуваннями, відповідно, нагромадженням коду. Ця логіка переслідує ідею єдиного реєстру конфігурацій усіх сцен, що наочно демонструє усю структуру застосунку без необхідності вивчати усі компоненти послідовно. А також, задля того, щоб в застосунку не було одного батьківського елементу, що, дозволяє створювати DOM на 1 елемент меншим, та дозволяє у одному застосунку мати абсолютно різні за структурою сцени, кожну, зі своєю окремою конфігурацією, що спрощує керування кожною з них."
        },
        {
          "type": "code",
          "language": "js",
          "content": "welcome_view: {\n        primary_structure: `\n                < main>\n                  < section id=\"welcome-block\"></section>\n                < /main>\n            `,\n        layout: [\n            \"WelcomeView\", \"QuickDocs\", \"CodeBlock\",\n            \"ExamplesList\", \"AddEntry\", \"EntriesList\",\n            \"EditEntry\", \"Footer\",\n        ],\n        config: {\n            WelcomeView: {\n                title: \"Horizon Dynamic UI\",\n                subtitle: \"Your scene-driven front-end engine\",\n                version: \"v0.1.19 Beta\",\n                tagline: \"Pure JS. No build. Host-ready.\",\n                CTA: {label: \"Get Started with Horizon\", link: \"#guide\"},\n            },\n            QuickDocs: {\n                links: [\n                    {label: \"\uD83D\uDCD8 What is Horizon?\", href: \"#guide\"},\n                    {label: \"\uD83D\uDE80 Creating Your First Scene\", href: \"#first-scene\"},\n                    {label: \"\uD83E\uDDE9 Component Structure\", href: \"#components\"}\n                ]\n            },\n            CodeBlock: {\n                codeSnippets: {\n                    example_js: {\n                        title: 'example_js',\n                        language: \"js\",\n                        content: `const msg = \"Hello Horizon\";`\n                    },\n                    example_html: {\n                        title: 'example_html',\n                        language: \"html\",\n                        content: `<div id=\"app\"></div>`\n                    }\n                }\n            },\n        },\n        linkHref: [\"https://unpkg.com/prismjs/themes/prism.css\"],\n        scriptSrc: [\"https://unpkg.com/prismjs/prism.js\", \"https://unpkg.com/prismjs/components/prism-javascript.min.js\"],\n    }"
        },
        {
        "type": "text",
        "content": "Як можна помітити у наведеному вище відрізку коду, конфігурація дозволяє додавати до кожної окремої сцени свої, ізольовані від інших сцен, стилі та скрипти. Це опція додана та залишена саме у <b>RegistryLayoutScheme.js</b> для того, щоб не \"розкидувати\" налаштування сцен по різних файлах та компонентах, що порушує закладену вище описаний принцип роботи фреймворку."
        },
        {
        "type": "text",
        "content": "Необхідно вказати структуру нової сцени, і для цього достатньо додати її назву у список <b>layout</b>. Для <b>WelcomeScene</b> це є назва її константи - <b>WelcomeScene</b> у самому компоненті. Щоб вказати, у який контейнер сцена має бути змонтована, цей контейнер потрібно буде ініціювати у <b>primary_structure</b>. Під капотом, <b>DUI</b> через <b>SceneManager</b> зчитає конфігурацію сцени з <b>RegistryLayoutScheme.js</b>, та змонтує код з <b>primary_structure:</b> безпосередньо у <b>< body id=\"app\">< /body></b>"
        },
        {
        "type": "text",
        "content": "Заключним етапом стане додавання назви сцени у <b>ComponentMap</b>, що розташований у <b>LayoutRegistryComponents.js</b>. Якщо у <b>RegistryLayoutScheme.js</b> ініціювався список назв компонентів, що будуть присутніми на сцені, то у <b>LayoutRegistryComponents.js</b> ініціюється список всіх компонентів, доступних для відображення у застосунку. Можна створити сцени, додати туди інші компоненти та якусь логіку, сконфігурувати їх, однак, вони не будуть показані, поки ці сцени та їх компоненти не будуть додані у список компонентів застосунку. Щоб це не заплутувало, варто тримати у пам'яті, що конфігурація сцен зберігається у файлі <b>RegistryLayoutScheme.js</b> - реєстр схеми макету, а список всіх компонентів застосунку, які доступні для показу, у - <b>LayoutRegistryComponents.js</b> - макет реєстрації компонентів. Перший - це, умовно, список службовців, що працюють у компанії. Другий - список обов'язків кожного службовця окремо."
        },
        {
        "type": "text",
        "content": "Саме цей файл знімає необхідність у кожній окремій сцені робити до неї імпорти її компонентів й імпорти самих сцен для <b>SceneManager</b>, котрий ці сцени монтує. Це централізація усіх імпортів компонентів у застосунку в одному файлі. Таким чином, це створює дуже комфортні умови для операцій з \"перекидання\", підключення та відключення компонентів між сценами через конфігураційний файл <b>RegistryLayoutScheme.js</b>."
        },
        {
        "type": "text",
        "content": "<b>LayoutRegistryComponents.js</b> для поточної версії DUI:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "// Pages\nimport { Page_404_View } from \"../../pages/reports/Page_404_View.js\";\nimport { WelcomeScene } from \"../../pages/WelcomeScene.js\";\n\n// Components\nimport { QuickDocs } from \"../../pages/guide/QuickDocs.js\";\nimport { CodeBlock } from \"../../components/CodeBlock.js\";\nimport { ExamplesList } from \"../../components/ExamplesList.js\";\nimport { AddEntry } from \"../../components/entry/AddEntry.js\";\nimport { EntriesList } from \"../../components/entry/EntriesList.js\";\nimport { EditEntry } from \"../../components/entry/EditEntry.js\";\nimport { Footer } from \"../../components/Footer.js\";\n\n// Guide\nimport { GuideMain } from \"../../pages/guide/GuideMain.js\";\nimport { GuideNavigation } from \"../../components/guide/GuideNavigation.js\";\nimport { GuideMenuItem } from \"../../components/guide/GuideMenuItem.js\";\nimport { GuideDescription } from \"../../components/guide/GuideDescription.js\";\n\nexport class LayoutRegistryComponents {\n    static\n    ComponentMap = Object.freeze({\n        // sceneName\n        Page404: Page_404_View,\n        WelcomeView: WelcomeScene,\n        // componentName\n        QuickDocs,\n        CodeBlock,\n        ExamplesList,\n        AddEntry,\n        EntriesList,\n        EditEntry,\n        Footer,\n        // Guide\n        GuideMain,\n        GuideNavigation,\n        GuideMenuItem,\n        GuideDescription,\n    });\n}"
        },
        {
        "type": "text",
        "content": "Базово, це той мінімум, що необхідно знати, щоб створити свою першу сцену, використовуючи <b>Horizon Dynamic UI</b>."
        }
      ]
    },
    "Основи роботи": {
      "Налаштування сцени/компоненту у RegistryLayoutScheme": [
        {
          "type": "text",
          "content": "<b>RegistryLayoutScheme.js</b> являє собою об'єкт, що містить, відповідні статичні ключі, значення для котрих необхідно закладати у залежності від очікуваного результату. Для кожної сцени є вже визначений набір ключів, котрими керується <b>SceneManager</b> при створенні сцени. Розглянемо на прикладі <b>WelcomeScene</b>:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "export const RegistryLayoutScheme = {\n    welcome_view: {\n        primary_structure: `\n                < main>\n                  < section id=\"welcome-block\">< /section>\n                < /main>\n            `,\n        layout: [\n            \"WelcomeView\", \"QuickDocs\", \"CodeBlock\",\n            \"ExamplesList\", \"AddEntry\", \"EntriesList\",\n            \"EditEntry\", \"Footer\",\n        ],\n        config: {\n            WelcomeView: {\n                title: \"Horizon Dynamic UI\",\n                subtitle: \"Your scene-driven front-end engine\",\n                version: \"v0.1.19 Beta\",\n                tagline: \"Pure JS. No build. Host-ready.\",\n                CTA: {label: \"Get Started with Horizon\", link: \"#guide\"},\n            },\n            QuickDocs: {\n                links: [\n                    {label: \"\uD83D\uDCD8 What is Horizon?\", href: \"#guide\"},\n                    {label: \"\uD83D\uDE80 Creating Your First Scene\", href: \"#first-scene\"},\n                    {label: \"\uD83E\uDDE9 Component Structure\", href: \"#components\"}\n                ]\n            },\n            CodeBlock: {\n                codeSnippets: {\n                    example_js: {\n                        title: 'example_js',\n                        language: \"js\",\n                        content: `const msg = \"Hello Horizon\";`\n                    },\n                    example_html: {\n                        title: 'example_html',\n                        language: \"html\",\n                        content: `<div id=\"app\"></div>`\n                    }\n                }\n            },\n        },\n        linkHref: [\"https://unpkg.com/prismjs/themes/prism.css\"],\n        scriptSrc: [\"https://unpkg.com/prismjs/prism.js\", \"https://unpkg.com/prismjs/components/prism-javascript.min.js\"],\n    }\n}"
        },
        {
          "type": "text",
          "content": "Особливості роботи <b>DUI</b> вимагають обов'язкове вказання контейнера компонента, у котрий буде змонтовантований вміст контейнеру. На прикладі <b>Vue.js</b> або <b>React.js</b> - це <code><b>div id=\"app\"</b></code>, у котрий монтується кожний новий компонент. Під час розробки <b>DUI</b>, ідеєю стало позбавитися зайвого <code><b>div</b></code>, що призвело до рішення відправною точкою для монтування залишити <code><b>body id=\"app\"</b></code>. Це дозволяє кожній окремій сцені монтувати у <code><b>body</b></code> своє, незалежне, <b>DOM</b>-дерево та свої, унікальні, залежності, не перевантажуючи імпортами та можливою логікою один централізований компонент, котра буде не витребувана в усіх інших випадках, окрім роботи із конкретною сценою. Для реалізації подібної структури необхідні два елемента, які доречно назвати конфігураційними. Вони належать до <b>Template Composition Engine</b> - частини ядра <b>Horizon Dynamic UI</b>, що займаються збіркою, налаштуванням та монтуванням сцени: <ul><li><b>RegistryLayoutScheme</b> необхідний для створення конфігурації сцени, згідно котрої вона буде створена.</li><li><b>LayoutRegistryComponents</b> необхідний для створення каталогу компонентів, котрі будуть доступні у застосунку для візуалізації.</li></ul>"
        },
        {
          "type": "text",
          "content": "<b>RegistryLayoutScheme</b> використовує спеціальні ключі:<ul><li><b>primary_structure</b> - де створюється \"main\" контейнер для відображення сцени</li><li><b>layout</b> - це масив, в котрий записуються усі компоненти, що мають бути доступні на сцені</li><li><b>config</b> - використовується для створення масиву даних, що \"з коробки\" доступні на сцені. Це може бути <b>title</b> сторінки, <b>meta</b>-заголовки, списки чогось, наприклад, кнопок. Власне, усе те, що знадобиться на сцені під час її створення. Так можна передати дані з <b>config</b> до сцени чи кожного компоненту, підключеного до сцени через <b>layout</b> </li><li><b>linkHref</b> - дозволяє кожній сцені мати свої, ізольовані від інших сцен, файли стилів</li><li><b>scriptSrc</b> - дозволяє кожній сцені мати свої, ізольовані від інших сцен, файли скриптів, наприклад, сторонніх бібліотек</li></ul>"
        }
      ],
      "Реєстрація сцени/компоненту у LayoutRegistryComponents": [
        {
          "type": "text",
          "content": "<b>LayoutRegistryComponents</b> необхідний для створення каталогу компонентів, котрі будуть доступні у застосунку для візуалізації. Усі інші компоненти, котрі, якщо, навіть, й сконфігуровані, не будуть відображені, якщо не будуть занесені у цей файл. По своїй суті, у цьому файлі зберігаються усі імпорти компонентів, які зчитує <b>SceneManager</b> та робить їх доступними по всьому застосунку. Це позбавляє необхідності робити імпорт компоненту у конкретній сцені, або, порушувати <b>DRY</b> повторюючи цей імпорт у іншій."
        },
        {
          "type": "text",
          "content": "Для поточної версії <b>DUI</b>, <b>LayoutRegistryComponents</b> виглядає наступним чином:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "// Pages\nimport { Page_404_View } from \"../../pages/reports/Page_404_View.js\";\nimport { WelcomeScene } from \"../../pages/WelcomeScene.js\";\n\n// Components\nimport { QuickDocs } from \"../../pages/guide/QuickDocs.js\";\nimport { CodeBlock } from \"../../components/CodeBlock.js\";\nimport { ExamplesList } from \"../../components/ExamplesList.js\";\nimport { AddEntry } from \"../../components/entry/AddEntry.js\";\nimport { EntriesList } from \"../../components/entry/EntriesList.js\";\nimport { EditEntry } from \"../../components/entry/EditEntry.js\";\nimport { Footer } from \"../../components/Footer.js\";\n\n// Guide\nimport { GuideMain } from \"../../pages/guide/GuideMain.js\";\nimport { GuideNavigation } from \"../../components/guide/GuideNavigation.js\";\nimport { GuideMenuItem } from \"../../components/guide/GuideMenuItem.js\";\nimport { GuideDescription } from \"../../components/guide/GuideDescription.js\";\n\nexport class LayoutRegistryComponents {\n    static\n    ComponentMap = Object.freeze({\n        // sceneName\n        Page404: Page_404_View,\n        WelcomeView: WelcomeScene,\n        // componentName\n        QuickDocs,\n        CodeBlock,\n        ExamplesList,\n        AddEntry,\n        EntriesList,\n        EditEntry,\n        Footer,\n        // Guide\n        GuideMain,\n        GuideNavigation,\n        GuideMenuItem,\n        GuideDescription,\n    });\n}"
        },
        {
          "type": "text",
          "content": "Така схема дозволяє спростити додавання, видалення або перенесення компоненту до іншої сцени без необхідності у кожній окремій сцені робити чи видаляти імпорти цього компоненту. Достатньо додати чи прибрати компонент з <b>layout</b> конкретної сцени у <b>RegistryLayoutScheme</b>."
        },
        {
          "type": "code",
          "language": "js",
          "content": "layout: [\n            \"WelcomeView\", \"QuickDocs\", \"CodeBlock\",\n            \"ExamplesList\", \"AddEntry\", \"EntriesList\",\n            \"EditEntry\", \"Footer\",\n        ]"
        }
      ],
      "Прив'язування стилів та скриптів": [
        {
          "type": "text",
          "content": "Як й інші фреймворки, <b>DUI</b> дозволяє додавати до кожної окремої сцени свої, ізольовані від інших сцен, файли стилів та скриптів. Для цього необхідно використати ключі <b>linkHref</b> та <b>scriptSrc</b> у <b>RegistryLayoutScheme</b>:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "linkHref: [\"https://unpkg.com/prismjs/themes/prism.css\"],\nscriptSrc: [\"https://unpkg.com/prismjs/prism.js\", \"https://unpkg.com/prismjs/components/prism-javascript.min.js\"],"
        },
        {
          "type": "text",
          "content": "Додавати значення обох масивів можливо списком, якщо файлів стилів чи скриптів є декілька</b>."
        }
      ],
      "Створення посилань та кнопок": [
        {
          "type": "text",
          "content": "Для роботи із посиланнями та кнопками у <b>Horizon Dynamic UI</b> доступний спектр інструментів. Кнопки та посилання можливо додати на сторінку трьома способами:<ul><li><b>ручне створення посилань та кнопок</b> - шляхом звичайного тегу <b>a</b> з <b>html</b></li><li><b>оголошення кнопок у межах mount() та виклик у шаблоні без необхідності дублювання коду</b>:</li></ul>"
        },
        {
          "type": "code",
          "language": "js",
          "content": "const CTA_label = config.CTA?.label || \"Explore\";\n    const CTA_link = config.CTA?.link?.trim() ? config.CTA.link : \"#page404\";\n\n    const processedConfig = {\n        ...config,\n        CTA_button: `< a href=\"${CTA_link}\" class=\"btn bg-gradient-info mt-3 fs-6\">\n             ${CTA_label}\n             < span class=\"badge\">${config.version}< /span>\n           < /a>`\n    };"
        },
        {
          "type": "text",
          "content": "Другий спосіб дозволяє створити одну кнопку/посилання, та додавати її у шаблон на будь-яке місце за допомогою <b>{CTA_button}</b>. Такий метод стає доречним у тих випадках, коли, у декількох місцях сторінки, необхідно відобразити однакову кнопку чи посилання. Наприклад у головному меню та футері, чи запрошуючи до реакції  на якусь пропозицію, у різних місцях сторінки, поки вона переглядається."
        },
        {
          "type": "text",
          "content": "Кнопка чи посилання додаються у блок <b>mount() {}</b> для її додавання у <b>DOM</b>-дерево під час його побудови. Так вона реалізована у <b>WelcomeScene</b>:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "mount(config = {}) {\n        const container = document.getElementById(\"welcome-block\");\n\n        if (!container) {\n            console.warn(\"[WelcomeScene] Container #welcome-block not found - component not mounted.\");\n            return;\n        }\n\n        const {title, subtitle, version, tagline, CTA} = config;\n\n        const CTA_label = config.CTA?.label || \"Explore\";\n        const CTA_link = config.CTA?.link?.trim() ? config.CTA.link : \"#page404\";\n\n        const processedConfig = {\n            ...config,\n            CTA_button: `< a href=\"${CTA_link}\" class=\"btn bg-gradient-info mt-3 fs-6\">\n                 ${CTA_label}\n                 < span class=\"badge\">${config.version}< /span>\n               < /a>`\n        };\n\n\n        container.innerHTML = renderTemplate(this.template, processedConfig);\n\n        if (typeof this.onMount === \"function\") {\n            this.onMount();\n        }\n    },"
        },
        {
          "type": "text",
          "content": "Спочатку запитуються дані з <b>RegistryLayoutScheme</b>, якщо такі були додані у <b>config</b> сцени. Як у даному випадку із <b>CTA</b>:"
        },
        {
          "type": "code",
          "language": "js",
          "content": "config: {\n        WelcomeView: {\n                title: \"Horizon Dynamic UI\",\n                subtitle: \"Your scene-driven front-end engine\",\n                version: \"v0.1.19 Beta\",\n                tagline: \"Pure JS. No build. Host-ready.\",\n                CTA: {label: \"Get Started with Horizon\", link: \"#guide\"},\n            },"
        },
        {
          "type": "text",
          "content": "Наступним кроком створюється кнопка та згодом, монтується сцена."
        },
        {
          "type": "text",
          "content": "<ul><li><b>генерація посилань та кнопок за допомогою хелпера <b>useCTA</b>, у котрих необхідна особливо налаштована логіка події</b>:</li></ul>"
        },
        {
          "type": "code",
          "language": "js",
          "content": "const btn = useCTA({ label: \"Дізнатися більше\", link: \"/pricing\" }, \"v1.2\", {\n  target: \"_blank\",\n  className: \"btn btn-info\",\n  title: \"Перейти до тарифів\"\n});\ndocument.querySelector(\"#cta-holder\").appendChild(btn);"
        },
        {
          "type": "text",
          "content": "Такий підхід дозволяє, так би мовити, \"костимізувати\" кнопку чи посилання необхідним чином для конкретного випадку. Вказати тип - <b>кнопка</b> чи <b>посилання</b>, список класів <b>CSS</b>-стилів, <b>id</b>, <b>title</b> та інші параметри хелпера <b>useCTA</b>."
        },
        {
          "type": "text",
          "content": "Кнопка чи посилання додаються у блок <b>mount() {}</b> для її додавання у <b>DOM</b>-дерево під час його побудови."
        }
      ],
      "Виклик messages": [
        {
          "type": "text",
          "content": "Виклик messages"
        }
      ],
      "Блок коду": [
        {
          "type": "text",
          "content": "Блок коду"
        }
      ]
    },
    "Глибше занурення у компоненти": {
      "config": [
        {
          "type": "code",
          "language": "js",
          "content": "const {title} = config;"
        },
        {
          "type": "code",
          "language": "js",
          "content": "const {codeSnippets = {}} = params;"
        },
        {
          "type": "code",
          "language": "js",
          "content": "this.onMount(config);"
        }
      ]
    },
    "Роутинг": {
      "Хеш-посилання": [
        {
          "type": "text",
          "content": "Хеш-посилання"
        }
      ],
      "Створення {CTA_button}": [
        {
          "type": "text",
          "content": "Створення {CTA_button}"
        }
      ],
      "Використання useCTA() хелпера": [
        {
          "type": "text",
          "content": "Використання useCTA() хелпера"
        }
      ]
    },
    "Реактивна підсистема": {
      "Робота з Dispatcher": [
        {
          "type": "text",
          "content": "Робота з Dispatcher"
        }
      ],
      "SceneMount": [
        {
          "type": "text",
          "content": "SceneMount"
        }
      ],
      "MessagesAgent": [
        {
          "type": "text",
          "content": "MessagesAgent"
        }
      ]
    },
    "Збереження даних у localStorage": {
      "Додавання":  [
        {
          "type": "text",
          "content": "Додавання"
        }
      ],
      "Зчитування": [
        {
          "type": "text",
          "content": "Завантаження"
        }
      ],
      "Видалення": [
        {
          "type": "text",
          "content": "Видалення"
        }
      ]
    },
    "Хелпери": {
      "renderTemplate": [
        {
          "type": "text",
          "content": "renderTemplate"
        }
      ],
      "useAssets": [
        {
          "type": "text",
          "content": "renderTemplate"
        }
      ],
      "useCTA": [
        {
          "type": "text",
          "content": "useCTA"
        }
      ],
      "useDispatcher": [
        {
          "type": "text",
          "content": "useDispatcher"
        }
      ],
      "useHighlight": [
        {
          "type": "text",
          "content": "useHighlight"
        }
      ],
      "useLocalStorage": [
        {
          "type": "text",
          "content": "useLocalStorage"
        }
      ],
      "useMessages": [
        {
          "type": "text",
          "content": "useMessages"
        }
      ],
      "useRouting": [
        {
          "type": "text",
          "content": "useRouting"
        }
      ]
    }
  }
}
